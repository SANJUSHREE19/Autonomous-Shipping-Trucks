{% extends 'base.html' %}

{% block content %}
<h1 style="margin-bottom: 30px;">Real-Time Truck Tracking</h1>

<div class="dashboard-grid" style="grid-template-columns: repeat(4, 1fr);">
    <div class="dashboard-card">
        <h3>Active Trucks</h3>
        <div class="number">{{ trucks|selectattr('status', 'equalto', 'Active')|list|length }}</div>
    </div>
    
    <div class="dashboard-card">
        <h3>Total Distance</h3>
        <div class="number">2,450 km</div>
    </div>
    
    <div class="dashboard-card">
        <h3>Average Speed</h3>
        <div class="number">
            {% set total_speed = 0 %}
            {% for truck in trucks %}
                {% set total_speed = total_speed + truck.speed|int %}
            {% endfor %}
            {% if trucks|length > 0 %}
                {{ (total_speed / trucks|length)|round(1) }}
            {% else %}
                0
            {% endif %}
            km/h
        </div>
    </div>
    
    <div class="dashboard-card">
        <h3>Updates</h3>
        <div class="number">Live</div>
    </div>
</div>

<div class="map-controls">
    <div class="control-group">
        <label for="filterStatus">Filter by Status:</label>
        <select id="filterStatus" onchange="filterTrucks()">
            <option value="all">All Trucks</option>
            {% for status in trucks|map(attribute='status')|unique %}
            <option value="{{ status }}">{{ status }}</option>
            {% endfor %}
        </select>
    </div>
    
    <div class="control-group">
        <label for="mapType">Map Type:</label>
        <select id="mapType" onchange="changeMapType()">
            <option value="roadmap">Road Map</option>
            <option value="satellite">Satellite</option>
            <option value="hybrid">Hybrid</option>
            <option value="terrain">Terrain</option>
        </select>
    </div>
    
    <div class="control-group toggle-controls">
        <label>
            <input type="checkbox" id="showTraffic" onchange="toggleTraffic()">
            Show Traffic
        </label>
        
        <label>
            <input type="checkbox" id="clusterMarkers" onchange="toggleClustering()">
            Cluster Trucks
        </label>
    </div>
</div>

<div class="content-grid">
    <div class="map-container">
        <div id="map" style="height: 100%; width: 100%; border-radius: 8px;"></div>
        <div id="map-loading" class="map-loading">
            <div class="spinner"></div>
            <span>Loading map...</span>
        </div>
    </div>
    
    <div class="truck-list">
        <div class="list-header">
            <h3>Truck Locations</h3>
            <div class="search-container">
                <input type="text" id="searchTruck" placeholder="Search truck..." onkeyup="searchTrucks()">
            </div>
        </div>
        
        <ul id="truck-locations">
            {% for truck in trucks %}
            <li class="truck-item status-{{ truck.status|lower }}" onclick="centerOnTruck('{{ truck.truck_id }}')" data-truck-id="{{ truck.truck_id }}" data-status="{{ truck.status }}">
                <div class="truck-info">
                    <span class="truck-id">Truck {{ truck.truck_id }}</span>
                    <span class="truck-status status-badge status-{{ truck.status|lower }}">{{ truck.status }}</span>
                </div>
                <div class="truck-details">
                    <div class="detail-item">
                        <span class="label">Location:</span>
                        <span class="value">{{ truck.location }}</span>
                    </div>
                    <div class="detail-item">
                        <span class="label">Speed:</span>
                        <span class="value">{{ truck.speed }} km/h</span>
                    </div>
                </div>
            </li>
            {% endfor %}
        </ul>
    </div>
</div>

<!-- Google Maps Script -->
<script>
    let map;
    let markers = {};
    let trafficLayer;
    let markerClusterer;
    let isClusteringEnabled = false;
    let directionsService;
    let directionsRenderer;
    let currentOpenInfoWindow = null;
    let activeTruckRoutes = {}; // To store { truckId: { path: [], currentStep: 0, speed: simulatedSpeed } }
    let animationInterval = null; // To control the animation loop

    // Create truck data arrays separate from the template logic
    const truckData = [];
    const truckCoordinates = {};

    {% for truck in trucks %}
    // Add truck data
    truckData.push({
        id: "{{ truck.truck_id }}",
        location: "{{ truck.location }}", // Keep original location string for display/fallback
        status: "{{ truck.status }}",
        speed: "{{ truck.speed }}"
    });

    // Add coordinates - with robust parsing
    {% set loc_parts = truck.location.split(',') %}
    {% if loc_parts|length == 2 %}
        truckCoordinates["{{ truck.truck_id }}"] = {
            lat: {{ loc_parts[0]|float('nan') }},
            lng: {{ loc_parts[1]|float('nan') }}
        };
    {% else %}
        // Fallback for non-coordinate locations or handle as error
        // For now, we'll log and potentially skip or use a default
        console.warn(`Truck {{ truck.truck_id }} has an invalid location format: '{{ truck.location }}'. Using NaN for coordinates.`);
        truckCoordinates["{{ truck.truck_id }}"] = {
            lat: NaN, // Or some default, or skip adding this truck to truckCoordinates
            lng: NaN
        };
    {% endif %}
    {% endfor %}

    function initMap() {
        console.log("Map initialization started");
        
        // Hide loading indicator when map is loaded
        const hideLoading = () => {
            document.getElementById('map-loading').style.display = 'none';
        };

        try {
            // Center on a central location initially
            const initialCenter = { lat: 39.8283, lng: -98.5795 };
            
            map = new google.maps.Map(document.getElementById("map"), {
                center: initialCenter,
                zoom: 4,
                styles: [
                    { elementType: "geometry", stylers: [{ color: "#242f3e" }] },
                    { elementType: "labels.text.stroke", stylers: [{ color: "#242f3e" }] },
                    { elementType: "labels.text.fill", stylers: [{ color: "#746855" }] },
                    {
                        featureType: "administrative.locality",
                        elementType: "labels.text.fill",
                        stylers: [{ color: "#d59563" }],
                    },
                    {
                        featureType: "road",
                        elementType: "geometry",
                        stylers: [{ color: "#38414e" }],
                    },
                    {
                        featureType: "road",
                        elementType: "geometry.stroke",
                        stylers: [{ color: "#212a37" }],
                    },
                    {
                        featureType: "road",
                        elementType: "labels.text.fill",
                        stylers: [{ color: "#9ca5b3" }],
                    },
                    {
                        featureType: "water",
                        elementType: "geometry",
                        stylers: [{ color: "#17263c" }],
                    },
                ],
                mapTypeControl: true,
                mapTypeControlOptions: {
                    style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
                },
                fullscreenControl: true,
                streetViewControl: false
            });
            
            console.log("Map object created");

            // Initialize traffic layer but don't display it yet
            trafficLayer = new google.maps.TrafficLayer();
            
            // Add markers for each truck
            const markerArray = [];
            
            // Add truck markers
            truckData.forEach(truck => {
                const marker = addTruckMarker(truck.id);
                if (marker) { // Only push valid markers
                    markerArray.push(marker);
                }
            });
            
            // Fit map to show all trucks
            if (markerArray.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                markerArray.forEach(marker => {
                    // This check is now redundant if we only pushed valid markers,
                    // but it's safe to keep it or rely on the filtered array.
                    if (marker) { 
                        bounds.extend(marker.getPosition());
                    }
                });
                map.fitBounds(bounds);
                
                // Don't zoom in too far on small datasets
                if (map.getZoom() > 15) {
                    map.setZoom(15);
                }
            }
            
            // Map is loaded
            hideLoading();
            console.log("Map initialized successfully");
            
            // Set up map idle event for performance
            map.addListener('idle', function() {
                updateVisibleTrucks();
            });
            
            // Initialize Directions Service and Renderer
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer();
            directionsRenderer.setMap(map); // Attach renderer to the map
            
        } catch (error) {
            console.error("Error initializing map:", error);
            document.getElementById('map').innerHTML = '<div class="error-message">Failed to initialize map: ' + error.message + '</div>';
            hideLoading();
        }
    }

    function addTruckMarker(truckId) {
        const position = truckCoordinates[truckId];
        const truck = truckData.find(t => t.id === truckId);
        
        // CRUCIAL CHECK: Do not create marker if coordinates are invalid or truck data is missing
        if (!truck) {
            console.error("addTruckMarker: Truck data not found for ID:", truckId);
            return null;
        }
        if (!position || isNaN(position.lat) || isNaN(position.lng)) {
            console.warn("addTruckMarker: Skipping marker for Truck ID:", truckId, "due to invalid/NaN coordinates. Position was:", position, "Original location string:", truck.location);
            return null; 
        }
        
        // Colors based on status
        const statusColors = {
            'Active': '#34a853',
            'Inactive': '#ea4335',
            'Maintenance': '#fbbc04',
            'Standby': '#4285f4'
        };
        
        const color = statusColors[truck.status] || '#ffffff';
        
        // Custom SVG truck icon
        const svgMarker = {
            path: "M8,0 L16,8 L16,16 L0,16 L0,8 Z",
            fillColor: color,
            fillOpacity: 0.9,
            strokeWeight: 1,
            strokeColor: '#ffffff',
            scale: 1.5,
            anchor: new google.maps.Point(8, 8),
        };

        const marker = new google.maps.Marker({
            position: position,
            map: map,
            title: "Truck " + truckId,
            icon: svgMarker,
            optimized: true,
            visible: true,
            // Store additional data on the marker object
            truckId: truckId,
            status: truck.status
        });

        const infoWindow = new google.maps.InfoWindow({
            content: `<div class="info-window">
                        <h3>Truck ${truckId}</h3>
                        <div class="info-detail">
                            <span class="info-label">Status:</span>
                            <span class="info-value status-${truck.status.toLowerCase()}">${truck.status}</span>
                        </div>
                        <div class="info-detail">
                            <span class="info-label">Speed:</span>
                            <span class="info-value">${truck.speed} km/h</span>
                        </div>
                        <div class="info-detail">
                            <span class="info-label">Location:</span>
                            <span class="info-value">${truck.location}</span>
                        </div>
                        <div class="action-buttons">
                            <button onclick="showTruckDetails('${truckId}')">Details</button>
                            <button onclick="displayTruckRoute('${truckId}')">Show Route</button>
                        </div>
                      </div>`
        });

        marker.addListener("click", () => {
            if (currentOpenInfoWindow) {
                currentOpenInfoWindow.close();
            }
            infoWindow.open(map, marker);
            currentOpenInfoWindow = infoWindow;
        });

        markers[truckId] = marker;
        return marker;
    }

    function centerOnTruck(truckId) {
        if (markers[truckId]) {
            map.setCenter(markers[truckId].getPosition());
            map.setZoom(14);
            
            // Open the info window for this truck
            new google.maps.event.trigger(markers[truckId], 'click');
            
            // Highlight the truck in the list
            highlightTruck(truckId);
        }
    }

    function highlightTruck(truckId) {
        // Remove highlighting from all trucks
        document.querySelectorAll('#truck-locations li').forEach(item => {
            item.classList.remove('highlighted');
        });
        
        // Add highlighting to the selected truck
        const truckItem = document.querySelector(`#truck-locations li[data-truck-id="${truckId}"]`);
        if (truckItem) {
            truckItem.classList.add('highlighted');
            // Scroll the item into view
            truckItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }

    function filterTrucks() {
        const statusFilter = document.getElementById('filterStatus').value;
        
        // Update marker visibility
        Object.keys(markers).forEach(truckId => {
            const marker = markers[truckId];
            const truck = truckData.find(t => t.id === truckId);
            
            if (truck) {
                // Show all or matching status
                marker.setVisible(statusFilter === 'all' || truck.status === statusFilter);
            }
        });
        
        // Update list visibility
        document.querySelectorAll('#truck-locations li').forEach(item => {
            const status = item.getAttribute('data-status');
            item.style.display = (statusFilter === 'all' || status === statusFilter) ? '' : 'none';
        });
    }

    function changeMapType() {
        const mapTypeId = document.getElementById('mapType').value;
        map.setMapTypeId(mapTypeId);
    }

    function toggleTraffic() {
        const showTraffic = document.getElementById('showTraffic').checked;
        if (showTraffic) {
            trafficLayer.setMap(map);
        } else {
            trafficLayer.setMap(null);
        }
    }

    function toggleClustering() {
        const checkbox = document.getElementById('clusterMarkers');
        alert('Clustering feature is currently being upgraded. Please check back soon!');
        checkbox.checked = false;
    }

    function searchTrucks() {
        const searchText = document.getElementById('searchTruck').value.toLowerCase();
        
        document.querySelectorAll('#truck-locations li').forEach(item => {
            const truckContent = item.textContent.toLowerCase();
            
            const isVisible = document.getElementById('filterStatus').value === 'all' || 
                              item.getAttribute('data-status') === document.getElementById('filterStatus').value;
            
            if (isVisible) {
                item.style.display = (truckContent.includes(searchText)) ? '' : 'none';
            }
        });
    }

    function updateVisibleTrucks() {
        // This function highlights trucks that are currently visible in the map viewport
        if (!map) return;
        
        const bounds = map.getBounds();
        if (!bounds) return;
        
        document.querySelectorAll('#truck-locations li').forEach(item => {
            const truckId = item.getAttribute('data-truck-id');
            const marker = markers[truckId];
            
            if (marker && marker.getVisible() && bounds.contains(marker.getPosition())) {
                item.classList.add('in-viewport');
            } else {
                item.classList.remove('in-viewport');
            }
        });
    }

    // Handle map loading errors
    window.gm_authFailure = function() {
        document.getElementById('map').innerHTML = '<div class="error-message">Google Maps authentication failed. Please check your API key.</div>';
        document.getElementById('map-loading').style.display = 'none';
    };
    
    function mapLoadError() {
        document.getElementById('map').innerHTML = '<div class="error-message">Failed to load Google Maps API. Please check your internet connection.</div>';
        document.getElementById('map-loading').style.display = 'none';
    }

    // Placeholder for showing more detailed truck information
    function showTruckDetails(truckId) {
        const truck = truckData.find(t => t.id === truckId);
        if (truck) {
            console.log("Details for truck:", truck);
            // In a real implementation, you might open a modal
            // or display more info in a dedicated section.
            alert(`Detailed information for Truck ${truckId} (see console for now):\nStatus: ${truck.status}\nSpeed: ${truck.speed} km/h\nLocation: ${truck.location}`);
        } else {
            alert("Truck details not found.");
        }
    }

    // Placeholder for displaying the truck's route
    async function displayTruckRoute(truckId) {
        const truck = truckData.find(t => t.id === truckId);
        if (!truck) {
            alert("Truck not found for route display.");
            return;
        }

        const truckCurrentPosition = truckCoordinates[truckId];
        if (!truckCurrentPosition) {
            alert("Truck current location not found.");
            return;
        }

        try {
            const response = await fetch(`/api/truck_schedule/${truckId}`);
            if (!response.ok) {
                const errorData = await response.json();
                alert(`Error fetching schedule: ${errorData.error || response.statusText}`);
                return;
            }
            const schedule = await response.json();

            if (!schedule || !schedule.destination) {
                alert(`Truck ${truckId}: No destination found in the schedule.`);
                return;
            }

            const originLatLng = new google.maps.LatLng(truckCurrentPosition.lat, truckCurrentPosition.lng);
            let destinationInput = schedule.destination;
            let finalDestination;

            // Check if destinationInput is a coordinate string (e.g., "lat,lng")
            if (typeof destinationInput === 'string' && destinationInput.includes(',')) {
                const parts = destinationInput.split(',');
                if (parts.length === 2) {
                    const lat = parseFloat(parts[0]);
                    const lng = parseFloat(parts[1]);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        finalDestination = new google.maps.LatLng(lat, lng);
                    } else {
                        alert(`Truck ${truckId}: Destination coordinates from schedule ('${destinationInput}') are invalid.`);
                        finalDestination = destinationInput; // Fallback to using as string if parsing fails
                    }
                } else {
                     alert(`Truck ${truckId}: Destination coordinate string from schedule ('${destinationInput}') is not in 'lat,lng' format.`);
                     finalDestination = destinationInput; // Fallback
                }
            } else {
                // If not a coordinate string, assume it's an address string
                finalDestination = destinationInput;
            }

            const travelMode = google.maps.TravelMode.DRIVING;

            const request = {
                origin: originLatLng,
                destination: finalDestination, 
                travelMode: travelMode
            };
            
            // Alert the final request object just before sending to API
            // alert(`DEBUG: Final Directions Request: Origin=${request.origin.toString()}, Destination=${request.destination.toString ? request.destination.toString() : request.destination}, Mode=${request.travelMode}`);

            directionsService.route(request, function(result, status) {
                if (status == google.maps.DirectionsStatus.OK) {
                    directionsRenderer.setDirections(result);
                    if (currentOpenInfoWindow) {
                        currentOpenInfoWindow.close();
                        currentOpenInfoWindow = null;
                    }

                    // Store the route path and start animation for this truck
                    const route = result.routes[0];
                    if (route && route.overview_path) {
                        console.log(`[Truck ${truckId}] Route found with overview_path. Length: ${route.overview_path.length}`); // DEBUG
                        const truckSpeed = parseFloat(truckData.find(t => t.id === truckId)?.speed || 50); 
                        activeTruckRoutes[truckId] = {
                            path: route.overview_path,
                            currentStep: 0,
                            speed: truckSpeed, 
                            marker: markers[truckId] 
                        };
                        startRouteAnimation(); 
                    } else {
                        // If route is OK but no overview_path, log this scenario
                        console.warn(`[Truck ${truckId}] DirectionsService returned OK, but no overview_path found or route object missing. Result:`, result);
                    }
                    
                } else {
                    // Single, more informative error alert
                    let alertMsg = `Failed to display route for Truck ${truckId}.\n`;
                    alertMsg += `Reason: ${status}\n`; // e.g., NOT_FOUND, ZERO_RESULTS
                    alertMsg += `Origin: ${originLatLng.toString()}\n`;
                    alertMsg += `Destination: ${finalDestination.toString()}\n`;
                    alertMsg += `Departure: ${schedule.departure_time || 'N/A'}\n`;
                    alertMsg += `Arrival: ${schedule.arrival_time || 'N/A'}\n`;
                    alertMsg += `Travel Mode: ${travelMode}`;
                    alert(alertMsg);
                }
            });

        } catch (error) {
            console.error("Error in displayTruckRoute:", error);
            alert("An error occurred while trying to display the route.");
        }
    }

    function startRouteAnimation() {
        if (animationInterval) return; // Already running

        const animationTickInterval = 1000; // Update position every 1 second (adjust for smoothness vs. performance)

        animationInterval = setInterval(() => {
            if (Object.keys(activeTruckRoutes).length === 0) {
                // No active routes, try to stop.
                stopRouteAnimation();
                return; // Exit early if no routes to process
            }
            console.log("Animation tick. Active routes:", Object.keys(activeTruckRoutes)); // DEBUG

            Object.keys(activeTruckRoutes).forEach(truckId => {
                const routeData = activeTruckRoutes[truckId];
                
                // console.log(`[Truck ${truckId}] Animating. Step: ${routeData?.currentStep}, Path length: ${routeData?.path?.length}`); // DEBUG - More verbose

                if (!routeData || !routeData.marker) {
                    console.warn(`[Truck ${truckId}] Missing routeData or marker in animation loop. Removing.`);
                    delete activeTruckRoutes[truckId]; 
                    return;
                }

                if (routeData.currentStep < routeData.path.length) {
                    console.log(`[Truck ${truckId}] Moving to step ${routeData.currentStep + 1}/${routeData.path.length}`); // DEBUG
                    routeData.marker.setPosition(routeData.path[routeData.currentStep]);
                    routeData.currentStep++;
                } else {
                    console.log(`[Truck ${truckId}] Reached destination.`);
                    delete activeTruckRoutes[truckId];
                    // No need to check Object.keys here again, next tick will handle it or stop if empty.
                }
            });
        }, animationTickInterval);
        console.log("Route animation started.");
    }

    function stopRouteAnimation() {
        if (animationInterval) {
            clearInterval(animationInterval);
            animationInterval = null;
            console.log("Route animation stopped.");
        }
    }
</script>

<!-- Load Google Maps API directly with the API key -->
<script async
    src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initMap"
    onerror="mapLoadError()">
</script>

<style>
    .content-grid {
        display: grid;
        grid-template-columns: 7fr 3fr;
        gap: 20px;
        margin-top: 20px;
    }

    .map-container {
        position: relative;
        height: 600px;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 1px 3px var(--shadow-color);
    }

    .map-loading {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        z-index: 1;
    }

    .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(255,255,255,0.3);
        border-top: 4px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 10px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Error message styling */
    .error-message {
        background-color: rgba(234, 67, 53, 0.1);
        color: var(--danger-color);
        padding: 20px;
        border-radius: 8px;
        text-align: center;
        font-weight: bold;
        margin-top: 20px;
    }
</style>
{% endblock %}